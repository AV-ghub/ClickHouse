PeerDB использует логическую репликацию Postgres, и это создает прямую конфронтацию с архитектурой ClickHouse, которая не поддерживает `UPDATE`/`DELETE` и имеет свой собственный DDL.

### Как PeerDB решает проблему "несовместимых" операций?

PeerDB не является "черным ящиком", который слепо переливает данные. Он реализует стратегии для преобразования операций из OLTP-мира (Postgres) в OLAP-мир (ClickHouse).

#### 1. Обработка `UPDATE` и `DELETE`

Это самая главная проблема. PeerDB использует два основных подхода:

**а) Преобразование в `INSERT` (По умолчанию и наиболее распространенный способ)**

PeerDB преобразует операции `UPDATE` и `DELETE` в операции вставки в ClickHouse. Для этого **требуется специальная структура таблицы в ClickHouse**.

*   **Стратегия:** `SOFT DELETE` или `INCREMENTAL SYNC`.
*   **Как это работает:**
    1.  Каждая таблица в ClickHouse получает два дополнительных системных столбца:
        *   `_peerdb_uid` (`String`): Уникальный идентификатор записи, обычно вычисляемый из первичного ключа и других данных.
        *   `_peerdb_timestamp` (`DateTime64` или аналог): Время, когда эта версия записи была вставлена в CH.
        *   `_peerdb_deleted` (`Bool` или `UInt8`): Флаг, помечающий запись как удаленную.
    2.  При **`INSERT`** из Postgres: строка вставляется в CH с `_peerdb_deleted = false`.
    3.  При **`UPDATE`** из Postgres: PeerDB трактует это как **удаление старой версии и вставку новой**. В CH вставляется **новая версия** строки с тем же `_peerdb_uid` (или новым, если изменился PK) и обновленным `_peerdb_timestamp`. Старая версия остается в таблице.
    4.  При **`DELETE`** из Postgres: В CH вставляется "гробница" (tombstone) — запись с тем же `_peerdb_uid`, актуальными данными на момент удаления (или только ключом, в зависимости от настройки) и `_peerdb_deleted = true`.

**Итог:** В вашей таблице ClickHouse хранится **полная история изменений** каждой записи.

**б) "Управляемые" таблицы и материализованные представления**

PeerDB может автоматически создавать и поддерживать "основную" таблицу с историей и **материализованное представление**, которое показывает только актуальное состояние.

*   **Основная таблица (`your_table_peerdb_raw`):** Хранит всю историю изменений, как описано выше.
*   **Представление (`your_table`):** Создается запросом, который для каждого `_peerdb_uid` выбирает запись с самым последним `_peerdb_timestamp` и где `_peerdb_deleted = false`.

Таким образом, при запросе к `your_table` вы видите актуальное "снимочное" состояние, как если бы `UPDATE` и `DELETE` выполнялись напрямую, но под капотом лежит неизменяемая лог-структура.

#### 2. Обработка DDL

С DDL все сложнее, и здесь PeerDB действует более осторожно.

*   **Несовместимые операции (например, `ALTER TABLE ... ADD COLUMN`):** PeerDB пытается отобразить DDL из Postgres в эквивалентный DDL ClickHouse. Это работает для простых операций (добавление столбца), но **часто терпит неудачу** для более сложных (изменение типа данных, добавление ограничений и т.д.).
*   **Стратегия:** Обычно DDL-операции не применяются к ClickHouse автоматически в продакшн-сценариях из-за риска несовместимости. Вместо этого используется один из подходов:
    1.  **Игнорирование DDL:** Коннектор настраивается так, чтобы пропускать DDL-события. Это означает, что схема в ClickHouse должна управляться отдельно (например, через миграции).
    2.  **Остановка репликации:** При обнаружении DDL-события репликация может быть приостановлена, требуя ручного вмешательства администратора для приведения схем в соответствие.

### Можно ли вмешаться и откорректировать процесс? Да!

PeerDB предоставляет несколько механизмов для контроля.

1.  **Настройка Мэппинга Таблиц (Table Mappings):**
    Вы можете точно указать, какие таблицы реплицировать, а какие — нет. Это базовая, но критически важная настройка.

    ```yaml
    # Пример в конфигурации PeerDB
    tables:
      - source: public.users
        destination: analytics.user_changes # Можно указать другое имя в CH
      - source: public.orders
        destination: analytics.orders_changes
    # Таблицу 'audit_logs' мы не реплицируем вообще.
    ```

2.  **Использование Synthetic Keys (для бесключевых таблиц):**
    Если в таблице Postgres нет первичного ключа, логическая репликация передает все значения столбцов. PeerDB может сгенерировать синтетический ключ на основе этих данных, чтобы отслеживать изменения в ClickHouse.

3.  **Режимы синхронизации:**
    Вы можете выбирать между разными режимами, которые влияют на производительность и согласованность:
    *   **XMIN:** Базовый режим, может быть не очень надежным.
    *   **CDC (Change Data Capture):** Использует слоты репликации Postgres. Это **рекомендуемый режим**, который гарантирует доставку всех изменений.

4.  **Обработка через собственную логику (наиболее гибкий способ):**
    PeerDB не обязан писать напрямую в целевую таблицу в ClickHouse. Вы можете настроить пайплайн так:
    *   PeerDB пишет данные в **промежуточную "сырую" таблицу** в ClickHouse (`_raw`).
    *   Вы создаете **представление** или **материализованное представление** поверх этой сырой таблицы, которое реализует вашу собственную бизнес-логику для обработки обновлений и удалений (например, с помощью `ARG_MAX`).
    *   Вы можете запускать периодические задачи (например, с помощью `ALTER TABLE ... DELETE WHERE`), чтобы физически удалять старые, неактуальные версии записей из сырой таблицы для экономии места.

### Практические рекомендации

1.  **Используйте CDC-режим репликации.**
2.  **Смиритесь с тем, что в ClickHouse будет храниться история изменений.** Это не недостаток, а особенность, которая открывает возможности для временного анализа.
3.  **Планируйте схему ClickHouse заранее.** Решите, будете ли вы использовать автоматические managed-таблицы от PeerDB или создадите свои собственные материализованные представления.
4.  **Тестируйте DDL-изменения.** Перед применением в продакшене проверьте, как PeerDB отреагирует на `ALTER TABLE` в вашей схеме Postgres. Будьте готовы управлять схемой ClickHouse вручную.
5.  **Начните с малого.** Протестируйте пайплайн на нескольких некритичных таблицах, чтобы понять поведение и настройки.

**Вывод:** PeerDB — это не черный ящик, а гибкий инструмент, который предоставляет стратегии для обхода фундаментальных различий между Postgres и ClickHouse. Вам **нужно будет вмешаться** в процесс, чтобы правильно его настроить, особенно в части проектирования финальных представлений данных в ClickHouse и управления DDL.
